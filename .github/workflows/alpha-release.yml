name: Alpha Release

on:
  workflow_dispatch:
  push:
    branches:
      - master

permissions:
  contents: write
  packages: write

jobs:
  alpha-release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          registry-url: 'https://registry.npmjs.org/'

      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 10

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('**/pnpm-lock.yaml') }}

      - name: Install Playwright browsers
        working-directory: packages/react
        run: pnpm exec playwright install --with-deps chromium

      - name: Run tests (core)
        env:
          CI: true
        run: pnpm run test:core

      - name: Build (core)
        run: pnpm run build:core

      - name: Run tests (react)
        env:
          CI: true
        run: pnpm run test:react --browser.headless=true --reporter=verbose --reporter=github-actions

      - name: Build (react)
        run: pnpm run build:react

      # --- Detect pending changesets ---
      - name: Check for pending Changesets
        id: changesets
        run: |
          echo "Checking for pending changesets..."
          npx changeset status --output status.json
          count=$(jq '.changesets | length' status.json)
          echo "Found $count pending changeset(s)"
          echo "count=$count" >> $GITHUB_OUTPUT

      # --- Detect packages that need to be published ---
      - name: Determine publish necessity
        id: publish_check
        run: |
          echo "Scanning for packages that need publishing..."
          needs_publish=0

          for pkg_json in packages/*/package.json; do
            pkg_name=$(node -p "require('./$pkg_json').name")
            local_version=$(node -p "require('./$pkg_json').version")
            echo "Checking $pkg_name (local v${local_version})"

            published_version=$(npm view "$pkg_name" version 2>/dev/null || echo "none")

            if [ "$published_version" = "none" ]; then
              echo "âš ï¸  $pkg_name has never been published â€” will publish."
              needs_publish=1
            elif [ "$published_version" != "$local_version" ]; then
              echo "ðŸš€ $pkg_name mismatch (local=$local_version, published=$published_version) â€” will publish."
              needs_publish=1
            else
              echo "âœ… $pkg_name is up to date."
            fi
          done

          echo "needs_publish=$needs_publish" >> $GITHUB_OUTPUT

      # --- Perform version bump if changesets exist ---
      - name: Version bump (alpha)
        if: steps.changesets.outputs.count != '0'
        run: |
          npx changeset version
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "chore: bump alpha versions [skip ci]" || echo "No version bump"
          git push || echo "No changes to push"

      # --- Determine highest version across all packages ---
      - name: Get max version from monorepo
        if: steps.changesets.outputs.count != '0' || steps.publish_check.outputs.needs_publish == '1'
        id: pkg
        run: |
          echo "Computing highest version among all packages..."
          versions=$(find packages -mindepth 2 -maxdepth 2 -name package.json -not -path "*/node_modules/*" -exec node -p "try { require('./{}').version } catch (e) {}" \; | grep -v '^undefined$')
          echo "Found versions:"
          echo "$versions"

          max_version=$(printf "%s\n" $versions | npx semver -r "*" | sort -rV | head -n 1)

          echo "Highest version: $max_version"
          echo "version=$max_version" >> $GITHUB_OUTPUT

      # --- Determine and create the next alpha tag ---
      - name: Determine next alpha tag
        if: steps.changesets.outputs.count != '0' || steps.publish_check.outputs.needs_publish == '1'
        id: tagger
        run: |
          echo "Determining next alpha tag..."
          git fetch --tags

          latest_tag=$(git tag --list 'v*-alpha.*' | sort -V | tail -n 1)
          echo "Latest alpha tag: $latest_tag"

          if [ -z "$latest_tag" ]; then
            echo "No previous alpha tags found, starting from v${{ steps.pkg.outputs.version }}-alpha.1"
            next_tag="v${{ steps.pkg.outputs.version }}-alpha.1"
          else
            base="${latest_tag%-*}-"
            num="${latest_tag##*-}"
            next_num=$((num + 1))
            next_tag="${base}${next_num}"
          fi

          echo "Next alpha tag: $next_tag"
          echo "tag=$next_tag" >> $GITHUB_OUTPUT

      - name: Create Git tag for version
        if: steps.changesets.outputs.count != '0' || steps.publish_check.outputs.needs_publish == '1'
        run: |
          git tag ${{ steps.tagger.outputs.tag }}
          git push origin ${{ steps.tagger.outputs.tag }}

      # --- Create GitHub release with autogenerated notes ---
      - name: Create GitHub Release
        if: steps.changesets.outputs.count != '0' || steps.publish_check.outputs.needs_publish == '1'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tagger.outputs.tag }}
          name: ${{ steps.tagger.outputs.tag }}
          generate_release_notes: true
          body: |
            ðŸš€ Automated Alpha Release: **${{ steps.tagger.outputs.tag }}**

            Highest monorepo version: v${{ steps.pkg.outputs.version }}

            This release includes the latest changes merged into the `master` branch.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # --- Publish all out-of-date packages ---
      - name: Publish alpha packages
        if: steps.changesets.outputs.count != '0' || steps.publish_check.outputs.needs_publish == '1'
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          set -e
          for pkg_json in packages/*/package.json; do
            pkg_dir=$(dirname "$pkg_json")
            cd "$pkg_dir"
            echo "Publishing $(node -p "require('./package.json').name")..."
            pnpm publish --tag alpha --access public --no-git-checks || echo "Already published"
            cd - >/dev/null
          done